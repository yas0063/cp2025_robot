# C言語ロボットプログラミング演習 - 内容概要

このドキュメントは、C言語によるロボットアーム制御プログラミング演習の全体構成をまとめたものです。

---

## 演習の全体構成

ガントリー型ロボットシミュレータを用いて、状態遷移を用いた構造化プログラミングの学習を通じて、段階的にロボット制御の複雑さに対応していく演習です。

### ロボットシミュレータの仕様
- グリッパ（ロボットの手）により物体を掴んで移動させるガントリー（直交）型ロボット
- 物体把持に失敗することもある（librobo2.a使用時）
- 物体の位置・形状・色を読み取る視覚センサ
- 把持中の物体の重さを計測する重量センサ
- アームの可動範囲: x, y ともに -1.0 ~ 1.0 の正方形平面内

---

## [第1回 ロボットを動かそう](pbl01.md)

### 学習内容
- ロボットプログラミングの基本構造と設計手法
- 構造化プログラミングと状態遷移の概念
- アームの駆動方法

### 主要な関数
- `initialize_robot(int object_num)` - シミュレーション環境の初期化
- `update_robot()` - シミュレーションの実行（1ステップ）
- `set_command_move_arm_to(Position target_position)` - アームを目標座標まで移動
- `get_arm_state()` - アームの状態を取得
- `get_update_robot_step()` - 現在の実行時間ステップ数を取得

### 状態遷移の例
```
MOVE_TO_A → MOVE_TO_B → FINISH
```

### 練習問題
`(x, y) = (0.5, -0.4)` と `(x, y) = (-0.3, 0.1)` を往復し続けるプログラムを作成

### 課題
キーボード入力された座標A, Cをもとに長方形軌道を2周描いて停止するプログラムを作成
- フィールド外の座標が指定された場合はエラー表示して終了
- **提出期限**: 1・2組 1/10 8:50、3・4組 1/20 13:30

---

## [第2回 センサ値を取得しよう](pbl02.md)

### 学習内容
- 物体情報の取得とデータ処理
- 把持動作と重量情報の取得
- Object構造体の利用

### Object構造体
```c
typedef struct{
    int index;
    Position position;
    ColorRGB color;
    double radius;
    double weight;
} Object;
```

### 主要な関数
- `get_object_position(int object_index)` - 物体の位置情報を取得
- `get_object_color_rgb(int object_index)` - 物体の色情報を取得
- `get_object_radius(int object_index)` - 物体の半径を取得
- `get_held_object_weight()` - 把持中の物体の重量を取得
- `set_command_pick_up_object()` - 物体を把持
- `set_command_release_object()` - 物体を解放
- `get_gripper_state()` - グリッパの状態を取得
- `get_system_time_in_sec()` - 経過時間を取得

### 状態遷移
```
MEASURE → APPROACH → PICKUP → RELEASE → FINISH
```

### 練習問題
5個すべての物体の重量を計測・表示するプログラムを作成

### 課題
N個（3〜31個）すべての物体の情報を表示するプログラムを作成
- 位置、重量、色（R,G,B）、半径
- 課題の遂行にかかった時間
- **librobo2.aを使用**（把持・解放の失敗あり）
- 把持・解放の失敗時は再試行処理を追加
- **提出期限**: 1・2組 1/24 8:50、3・4組 1/27 13:30

---

## [第3回 物体を並べ替えよう](pbl03.md)

### 学習内容
- ピック＆プレース動作の繰り返しによる物体の並び替え
- 物体情報の更新
- 複数物体の整列アルゴリズム

### 初期配置
各物体の初期状態は `(-0.5, -0.5)`、`(-0.5, 0.5)`、`(0.5, 0.5)`、`(0.5, -0.5)` で囲まれる領域からランダムに選ばれる

### 新しい関数
- `int minimum_object_number(Object *object)` - 最小半径の物体番号を返す
- `void object_move(Object *object, int *n, Position target_pos)` - 物体を目標位置へ移動

### 状態遷移
```
MEASURE → SEARCH → APPROACH → PICKUP → MOVE → PLACE → FINISH
```

### 練習問題
5個すべての物体を上部の領域 `(y = 0.7)` に横一列に左から右に向かって、半径の小さい順に並べるプログラムを作成
- ヒント: 物体情報配列objectを半径でソート。x座標を変化させて並べる

### 課題
5個すべての物体を重量の**大きい**順に並べるプログラムを作成
- まず、すべての物体の重量を計測
- その後、重量の大きい順に、横一列 `(y = 0.7)` に左から右に向かって物体を整列
- ヒント: 重量計測か整列かの課題達成状況で場合分け
- **提出期限**: 1・2組 1/31 8:50、3・4組 2/3 8:50

---

## [最終課題（最終レポート）](pbl_final.md)

### 問題点
物体を並べていくとき、移動先に別の物体があると解放できない

### 基本課題

#### 課題1
7個の物体を中央 `(x = 0.0)` に半径の小さい順に縦並びに配置させるプログラムを作成
- 7個全ての物体を右手 `(x = 0.7)` に退避させてから配置
- 作業の完了までにかかった時間を表示

#### 課題2
課題1で作成したプログラムを改良して、物体をなるべく早く配置できるプログラムを作成
- 改良プログラムと元のプログラムの作業時間を比較
- 物体の位置はランダムなので、10回程度実行した結果の平均値で比較
- どれだけ高速化できたかを定量的に示す

#### 参考
- 組み合わせ爆発の問題: n個の物体を並べていく順番の組み合わせは nPn
- 個数が増えると計算時間が爆発的に増大

### 発展課題（余力がある人向け）
7個の物体を中央 `(x = 0.0)` に重量の小さい順に縦並びに配置させるプログラムを作成
- できるだけ高速な配置を目指す

### 提出物
- 基本課題: プログラムファイル
- 基本課題: 高速化のアイデアを書いたテキストファイル
- 基本課題: 作業時間を比較したエクセルファイルなど（形式は自由）
- （できた人は）発展課題: プログラムファイル
- 総合演習の授業の感想を書いたテキストファイル

**提出期限**: 1・2組 2/7 23:59、3・4組 2/10 23:59

---

## 注意事項（全課題共通）

### コーディング規約
- 適宜コメントを入れる
- 関数化して他人にもわかりやすいプログラムにする
- 全くコメントのないものは減点

### 不正行為
- 他人のプログラムを写したことが判明した場合は、両者とも0点
- 課題内容に対応していないプログラムにも点をつけない

### 提出先
CLE上のレポートbox

---

## 演習の進行とスキル習得

| 回 | テーマ | 習得スキル |
|---|---|---|
| 第1回 | ロボットを動かそう | 状態遷移、アーム制御の基本 |
| 第2回 | センサ値を取得しよう | センシング、データ構造、エラーハンドリング |
| 第3回 | 物体を並べ替えよう | ピック＆プレース、ソートアルゴリズム |
| 最終 | 総合課題 | 干渉回避、最適化、アルゴリズム改良 |
